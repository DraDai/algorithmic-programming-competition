//模板实数三分,用来求单峰函数
/*问题描述：给出一个N次函数，保证在区间[l, r]内存在一点x，使得函数在[l, x]上单调递增，[x, r]上单调递减
，求出x的值*/

//在最大值函数区间内取两个mid值，其中mid1<mid2，若f(mid1)<f(mid2)，则最值一定在mid1的右侧，若f(mid1)>f(mid2)，则最值在mid2的左侧
#include<stdio.h>
#include<iostream>
#include<math.h>
#include<math.h>
using namespace std;
//设置一个很小的数eps，当mid2-mid1<eps时可得近似值
const double eps = 1.0e-6;
int n;
//函数各系数
double a[15];
//已知mid，计算函数值
double f(double x)
{
	double s = 0;
	for (int i = n; i >= 0; i--)
	{
		s = s * x + a[i];
	}
	return s;
}

int main()
{
	//左右区间
	double L, R;
	scanf_s("%d%lf%lf", &n, &L, &R);
	//输入函数系数
	for (int i = n; i >= 0; i--)
	{
		scanf_s("%lf", &a[i]);
	}
	//近似实数三分
	while (R - L > eps)
	{
		double mid = L + (R - L) / 2.0;
		if (f(mid - eps) < f(mid))
			L = mid;
		else
			R = mid;
	}
	printf("%.5lf\n", R);
}