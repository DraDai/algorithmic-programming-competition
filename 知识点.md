//模板实数三分,用来求单峰函数
/*问题描述：给出一个N次函数，保证在区间[l, r]内存在一点x，使得函数在[l, x]上单调递增，[x, r]上单调递减
，求出x的值*/

//在最大值函数区间内取两个mid值，其中mid1<mid2，若f(mid1)<f(mid2)，则最值一定在mid1的右侧，若f(mid1)>f(mid2)，则最值在mid2的左侧
#include<stdio.h>
#include<iostream>
#include<math.h>
#include<math.h>
using namespace std;
//设置一个很小的数eps，当mid2-mid1<eps时可得近似值
const double eps = 1.0e-6;
int n;
//函数各系数
double a[15];
//已知mid，计算函数值
double f(double x)
{
	double s = 0;
	for (int i = n; i >= 0; i--)
	{
		s = s * x + a[i];
	}
	return s;
}

int main()
{
	//左右区间
	double L, R;
	scanf_s("%d%lf%lf", &n, &L, &R);
	//输入函数系数
	for (int i = n; i >= 0; i--)
	{
		scanf_s("%lf", &a[i]);
	}
	//近似实数三分
	while (R - L > eps)
	{
		double mid = L + (R - L) / 2.0;
		if (f(mid - eps) < f(mid))
			L = mid;
		else
			R = mid;
	}
	printf("%.5lf\n", R);
}

/*某小学最近得到了一笔赞助，打算拿出其中一部分为学习成绩优秀的前 
5名学生发奖学金。期末，每个学生都有 3 门课的成绩:语文、数学、英
语。先按总分从高到低排序，如果两个同学总分相同，再按语文成绩从高
到低排序，如果两个同学总分和语文成绩都相同，那么规定学号小的同学 
排在前面，这样，每个学生的排序是唯一确定的。

任务：先根据输入的 3门课的成绩计算总分，然后按上述规则排序，最后
按排名顺序输出前五名名学生的学号和总分。注意，在前5名同学中，每个
人的奖学金都不相同，因此，你必须严格按上述规则排序。例如，在某个
正确答案中，如果前两行的输出数据(每行输出两个数:学号、总分) 是:

7279
5279

这两行数据的含义是:总分最高的两个同学的学号依次是7号、5号。这两
名同学的总分都是279 (总分等于输入的语文、数学、英语三科成绩之和)
，但学号为 7 的学生语文成绩更高一些。如果你的前两名的输出数据是:

5279
7279

则按输出错误处理，不能得分。*/
//c++模板sort
//sort()简单例子
/*
#include<algorithm>
#include<vector>
bool my_less(int i, int j) { return (i < j);}	//自定义小于
bool my_greater(int i, int j) { return (i > j);}	//自定义大于
int main()
{
	vector<int> a = { 3, 7, 2, 5, 6, 8, 5, 4 };
	sort(a.begin(), a.begin() + 4);	//对前四个排序
	sort(a.begin(), a.end());	//从小到大排序
	sort(a.begin(), a.end(), my_less);	//自定义从小到大排序
	sort(a.begin(), a.end(), greater<int>());	//从大到小排序
	sort(a.begin(), a.end(), my_greater);	//自定义从大到小排序
	return 0;
}
*/

#include<iostream>
#include<algorithm>
using namespace std;
//设置学生成绩结构
struct stu {
	int id;		//学号
	int c, m, e;	//语文、数学、英语
	int sum;	//总分
}st[305];
//自定义结构大小比较
bool cmp(stu a, stu b)
{
	if (a.sum > b.sum)
		return true;
	else if (a.sum < b.sum)
		return false;
	else
	{
		if (a.c > b.c)
			return true;
		else if (a.c < b.c)
			return false;
		else
		{
			if (a.id < b.id)
				return true;
			else
				return false;
		}
	}
}

int main()
{
	int n;
	cin >> n;
	//输入学生信息
	for (int i = 0; i < n; i++)
	{
		st[i].id = i + 1;
		cin >> st[i].c >> st[i].m >> st[i].e;
		st[i].sum = st[i].c + st[i].e + st[i].m;
	}
	sort(st, st + n, cmp);
	for (int i = 0; i < 5; i++)
	{
		cout << st[i].id << ' ' << st[i].sum << endl;
	}
	return 0;
}





//c++模板排列函数
//next_permutation()全排列函数
/*
假设有3个字符{a, b, c}组成的的序列a，可以用next_permutation(a.begin(), a.end())对序列a进行排列、
它会按字典序返回abc acb bac bca cab cba
*/

//从当前全排列开始逐个输出更大的排列
#include<iostream>
#include<algorithm>
using namespace std;

int main()
{
	//创建一个序列
	string a = "bca";
	do
	{
		//输出序列
		cout << a << endl;
	} while (next_permutation(a.begin(), a.end()));
	//会输出bca	cab	cba

	//将此序列进行排序
	sort(a.begin(), a.end());
	do
	{
		//输出序列
		cout << a << endl;
	} while (next_permutation(a.begin(), a.end()));
	//会输出abc acb bac bca cab cba
	return 0;
}





#include<iostream>
#include<algorithm>
using namespace std;

//自写全排列函数,进行部分排列
int a[20] = { 1, 2, 3,4,5,6,7,8,9,10,11,12,13 };
bool vis[20];	//记录第i个数是否被选过
int b[20];	//生成的一个全排列

//递归产生全排列,本质是回溯算法
void dfs(int s, int t)
{
	//树的深度就是t,s是当前树的深度
	//递归到树的叶结点输出一个全排列
	if (s == t)
	{
		for (int i = 0; i < t; i++)
			cout << b[i] << " ";
		cout << endl;
		return;
	}
	//深度为i的节点有t-i个分支
	for (int i = 0; i < t; i++)
	{
		//找到一个未选中的分支
		if (!vis[i])
		{
			vis[i] = true;	//打上标记，表示选中
			b[s] = a[i];	//将该下标中表示的a数组元素给b
			dfs(s + 1, t);	//递归
			//回溯
			vis[i] = false;
		}
	}
}

int main()
{
	int n = 3;
	dfs(0, n);
	return 0;
}

//最后生成为
/*
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
*/







//静态二叉树的BFS
#include<iostream>
#include<queue>
using namespace std;
const int N = 100005;
//静态二叉树的结构
struct Node
{
	char value;	//数据
	int lson, rson;	//左右孩子
}tree[N];
int index = 1;	//记录节点存在的位置
//创建节点,返回节点的位置
int newNode(char val)
{
	tree[index].value = val;	//tree[0]不用，0表示空节点
	tree[index].lson = 0;
	tree[index].rson = 0;
	return index++;
}
//插入函数,l_r的0或1表示左孩子和右孩子
void Insert(int& father, int child, int l_r)
{
	if (l_r == 0)
		tree[father].lson = child;
	else
		tree[father].rson = child;
}
//创建一颗静态二叉树
int buildtree()
{
	int A = newNode('A');int B = newNode('B');int C = newNode('C');
	int D = newNode('D');int E = newNode('E');int F = newNode('F');
	int G = newNode('G');int H = newNode('H');int I = newNode('I');
	Insert(E, B, 0);	Insert(E, G, 1);
	Insert(B, A, 0);	Insert(B, D, 1);
	Insert(G, F, 0);	Insert(G, I, 1);
	Insert(D, C, 0);	Insert(I, H, 0);
	int root = E;
	return root;
}

//BFS算法
int main()
{
	int root = buildtree();
	//创建队列
	queue<int> q;
	q.push(root);	//从根节点开始
	while (q.size())
	{
		int tmp = q.front();
		cout << tree[tmp].value << " ";
		q.pop();	//弹出节点
		if (tree[tmp].lson != 0)	//入队孩子节点
			q.push(tree[tmp].lson);
		if (tree[tmp].rson != 0)
			q.push(tree[tmp].rson);
	}
	return 0;
}







//DFS的代码框架
//分三步走，1、找终止条件。2、判断单层逻辑。3、递归下一层

ans;	//答案，用全局变量表示
void dfs(层数，其他参数)
{
	if (出局条件判断)	//一般是到达最底层，或者满足条件退出
	{
		更新答案;	//答案一般用全局变量表示
		retrun;		//返回到上一层
	}
	(剪枝)	//在进一步递归之前剪枝，除去不必要的递归
	for(枚举下一层可能的情况)	//对每个情况进行DFS，二叉树就是递归左右子树
		if(used[i] == 0)	//如果状态i没有用过，就进入下一层
		{
			used[i] = 1;	//标记状态i，表示已经用过，更底层不能使用
			dfs(层数 + 1，其他参数);	//继续递归下一层
			used[i] = 0;	//恢复状态，不影响上一层使用
		}
	return;		//返回上一层
}